// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "/home/ocommeng/obdgpslogger-0.16/build/src/sim/simguifltk.h"
#include <string.h>
#include <stdio.h>
#include "obdservicecommands.h"
#include "dtccodes.h"

void SimGenGui_Fltk::cb_Quit_i(Fl_Menu_*, void*) {
  w->hide();
}
void SimGenGui_Fltk::cb_Quit(Fl_Menu_* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->user_data()))->cb_Quit_i(o,v);
}

Fl_Menu_Item SimGenGui_Fltk::menu_[] = {
 {"&File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Quit", 0,  (Fl_Callback*)SimGenGui_Fltk::cb_Quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void SimGenGui_Fltk::cb_simval_rpm_i(Fl_Dial* o, void*) {
  output_rpm->value(o->value());
}
void SimGenGui_Fltk::cb_simval_rpm(Fl_Dial* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_simval_rpm_i(o,v);
}

void SimGenGui_Fltk::cb_simval_throttlepos_i(Fl_Dial* o, void*) {
  output_throttlepos->value(o->value());
}
void SimGenGui_Fltk::cb_simval_throttlepos(Fl_Dial* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_simval_throttlepos_i(o,v);
}

void SimGenGui_Fltk::cb_simval_maf_i(Fl_Dial* o, void*) {
  output_maf->value(o->value());
}
void SimGenGui_Fltk::cb_simval_maf(Fl_Dial* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_simval_maf_i(o,v);
}

void SimGenGui_Fltk::cb_simval_vss_i(Fl_Dial* o, void*) {
  output_vss->value(o->value());
}
void SimGenGui_Fltk::cb_simval_vss(Fl_Dial* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_simval_vss_i(o,v);
}

void SimGenGui_Fltk::cb_simval_temp_i(Fl_Dial* o, void*) {
  output_temp->value(o->value());
}
void SimGenGui_Fltk::cb_simval_temp(Fl_Dial* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_simval_temp_i(o,v);
}

void SimGenGui_Fltk::cb_dtc_list_i(Fl_Check_Browser* o, void*) {
  dtc_removeunchecked(o);
}
void SimGenGui_Fltk::cb_dtc_list(Fl_Check_Browser* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_dtc_list_i(o,v);
}

void SimGenGui_Fltk::cb_Add_i(Fl_Button*, void*) {
  if(dtc_isvalid(dtc_addcode->value())) {
	dtc_list->add(dtc_addcode->value(),1);
	dtc_addcode->value("");
}
	
Fl::redraw();
}
void SimGenGui_Fltk::cb_Add(Fl_Button* o, void* v) {
  ((SimGenGui_Fltk*)(o->parent()->parent()->user_data()))->cb_Add_i(o,v);
}

SimGenGui_Fltk::SimGenGui_Fltk() {
  { w = new Fl_Double_Window(565, 310, "OBDII Simulator");
    w->user_data((void*)(this));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 565, 20);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { Fl_Group* o = new Fl_Group(5, 45, 370, 260, "Mode 1 Values");
      o->box(FL_UP_BOX);
      o->labelsize(11);
      { Fl_Dial* o = simval_rpm = new Fl_Dial(25, 60, 100, 90, "Engine RPM");
        simval_rpm->type(1);
        simval_rpm->labelsize(11);
        simval_rpm->callback((Fl_Callback*)cb_simval_rpm);
        configure_widget(o,"rpm");
      } // Fl_Dial* simval_rpm
      { Fl_Dial* o = simval_throttlepos = new Fl_Dial(135, 60, 100, 90, "Throttle Position");
        simval_throttlepos->type(1);
        simval_throttlepos->labelsize(11);
        simval_throttlepos->callback((Fl_Callback*)cb_simval_throttlepos);
        configure_widget(o,"throttlepos");
      } // Fl_Dial* simval_throttlepos
      { Fl_Dial* o = simval_maf = new Fl_Dial(85, 185, 100, 90, "Mass Airflow");
        simval_maf->type(1);
        simval_maf->labelsize(11);
        simval_maf->callback((Fl_Callback*)cb_simval_maf);
        configure_widget(o,"maf");
      } // Fl_Dial* simval_maf
      { Fl_Dial* o = simval_vss = new Fl_Dial(210, 185, 100, 90, "Vehicle Speed");
        simval_vss->type(1);
        simval_vss->labelsize(11);
        simval_vss->callback((Fl_Callback*)cb_simval_vss);
        configure_widget(o,"vss");
      } // Fl_Dial* simval_vss
      { Fl_Dial* o = simval_temp = new Fl_Dial(250, 60, 100, 90, "Engine Temp");
        simval_temp->type(1);
        simval_temp->labelsize(11);
        simval_temp->callback((Fl_Callback*)cb_simval_temp);
        configure_widget(o,"temp");
      } // Fl_Dial* simval_temp
      { output_rpm = new Fl_Value_Output(45, 130, 60, 20);
        output_rpm->step(1);
      } // Fl_Value_Output* output_rpm
      { output_throttlepos = new Fl_Value_Output(155, 130, 60, 20);
        output_throttlepos->step(1);
      } // Fl_Value_Output* output_throttlepos
      { output_temp = new Fl_Value_Output(270, 130, 60, 20);
        output_temp->step(1);
      } // Fl_Value_Output* output_temp
      { output_maf = new Fl_Value_Output(105, 255, 60, 20);
        output_maf->step(1);
      } // Fl_Value_Output* output_maf
      { output_vss = new Fl_Value_Output(230, 255, 60, 20);
        output_vss->step(1);
      } // Fl_Value_Output* output_vss
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(380, 45, 180, 260, "DTCs");
      o->box(FL_UP_BOX);
      o->labelsize(11);
      { dtc_report = new Fl_Check_Button(385, 275, 115, 25, "Report DTCs");
        dtc_report->down_box(FL_DOWN_BOX);
        dtc_report->labelsize(11);
      } // Fl_Check_Button* dtc_report
      { Fl_Check_Button* o = dtc_mil = new Fl_Check_Button(510, 275, 45, 25, "MIL");
        dtc_mil->down_box(FL_DOWN_BOX);
        dtc_mil->labelsize(11);
        o->value(1);
      } // Fl_Check_Button* dtc_mil
      { Fl_Check_Browser* o = dtc_list = new Fl_Check_Browser(385, 105, 165, 170, "Click DTC to remove");
        dtc_list->labelsize(11);
        dtc_list->textsize(11);
        dtc_list->callback((Fl_Callback*)cb_dtc_list);
        dtc_list->align(Fl_Align(FL_ALIGN_TOP));
        dtc_list->when(FL_WHEN_CHANGED);
        o->add("P0103", 1);
      } // Fl_Check_Browser* dtc_list
      { dtc_addcode = new Fl_Input(385, 60, 125, 20);
        dtc_addcode->labelsize(11);
        dtc_addcode->textsize(11);
      } // Fl_Input* dtc_addcode
      { Fl_Button* o = new Fl_Button(515, 60, 35, 20, "Add");
        o->labelsize(11);
        o->callback((Fl_Callback*)cb_Add);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    w->end();
  } // Fl_Double_Window* w
  addSupportedCommand("dtc_cnt");
}

void SimGenGui_Fltk::show() {
  w->show();
}

void SimGenGui_Fltk::configure_widget(Fl_Dial *w, const char *name) {
  addSupportedCommand(name);
  
  struct obdservicecmd *osc = obdGetCmdForColumn(name);
  if(NULL == osc) w->range(0,200);
  else w->range(osc->min_value,osc->max_value);
}

void SimGenGui_Fltk::addSupportedCommand(const char *columnname) {
  struct obdservicecmd *cmd = obdGetCmdForColumn(columnname);
  
  if(NULL == cmd) {
  	fprintf(stderr,"Couldn't find cmd for column %s\n", columnname);
  	return;
  }
  
  unsigned int pid = cmd->cmdid;
  
  if(pid <= 0x20) {
  	supportedpids_00 |= ((unsigned long)1<<(0x20 - pid));
  } else if(pid > 0x20 && pid <= 0x40) {
  	supportedpids_20 |= ((unsigned long)1<<(0x40 - pid));
  } else if(pid > 0x40 && pid <= 0x60) {
  	supportedpids_40 |= ((unsigned long)1<<(0x60 - pid));
  } else if(pid > 0x60 &&  pid <= 0x80) {
  	supportedpids_60 |= ((unsigned long)1<<(0x80 - pid));
  } else {
  	fprintf(stderr,"Don't support PIDs this high in sim yet: %i\n", pid);
  }
}

void SimGenGui_Fltk::dtc_removeunchecked(Fl_Check_Browser *brows) {
  int i = brows->nitems();
  
  for(;i>0;i--) {
  	if(0 == brows->checked(i)) {
  		brows->remove(i);
  	}
  }
}

const char * guifltk_simgen_name() {
  return "gui_fltk";
}

const char * guifltk_simgen_longdesc() {
  return "GUI generator using FLTK\n"
  	"Seed: Ignored";
}

int guifltk_simgen_create(void **gen, const char *seed) {
  SimGenGui_Fltk *f = new SimGenGui_Fltk();
  
  if(NULL == f) return 1;
  
  f->show();
  
  *gen = static_cast<void *>(f);
  return 0;
}

void guifltk_simgen_destroy(void *gen) {
  delete static_cast<SimGenGui_Fltk *>(gen);
}

int guifltk_simgen_getvalue(void *gen, unsigned int mode, unsigned int PID, unsigned int *A, unsigned int *B, unsigned int *C, unsigned int *D) {
  SimGenGui_Fltk *f = static_cast<SimGenGui_Fltk *>(gen);
  if(NULL == f || 0 == f->w->shown()) {
  	return -1;
  }
  
  
  if(0x00 == PID || 0x20 == PID || 0x40 == PID || 0x60 == PID) {
  	unsigned long bits = 0;
  	
  	if(0x00 == PID) bits = f->supportedpids_00;
  	else if(0x20 == PID) bits = f->supportedpids_20;
  	else if(0x40 == PID) bits = f->supportedpids_40;
  	else if(0x60 == PID) bits = f->supportedpids_60;
  	else return 0;
  
  	*D = bits & 0xFF;
  	bits >>= 8;
  	*C = bits & 0xFF;
  	bits >>= 8;
  	*B = bits & 0xFF;
  	bits >>= 8;
  	*A = bits & 0xFF;
  
  	return 4;
  
  } else if(0x01 == PID) {
  	*B = *C = *D = 0x00;
  	
  	if(f->dtc_report->value()) {
  		*A = (f->dtc_mil->value()?0x80:0x00);
  		*A += f->dtc_list->nitems();
  	} else {
  		*A = 0;
  	}
  	
  	return 4;
  } else {
  
  	struct obdservicecmd *cmd = obdGetCmdForPID(PID);
  
  	if(NULL == cmd || NULL == cmd->db_column || 0 == strlen(cmd->db_column))
  		return 0;
  
  	if(0 == strcmp(cmd->db_column, "vss")) {
  		return cmd->convrev(f->simval_vss->value(), A, B, C, D);
  	} else if(0 == strcmp(cmd->db_column, "rpm")) {
  		return cmd->convrev(f->simval_rpm->value(), A, B, C, D);
  	} else if(0 == strcmp(cmd->db_column, "maf")) {
  		return cmd->convrev(f->simval_maf->value(), A, B, C, D);
  	} else if(0 == strcmp(cmd->db_column, "throttlepos")) {
  		return cmd->convrev(f->simval_throttlepos->value(), A, B, C, D);
  	} else if(0 == strcmp(cmd->db_column, "temp")) {
  		return cmd->convrev(f->simval_temp->value(), A, B, C, D);
  	}
  	
  	return 0;
  }
}

int guifltk_simgen_idle(void *gen, int idlems) {
  Fl::wait(idlems/1000.0f);
  SimGenGui_Fltk *f = static_cast<SimGenGui_Fltk *>(gen);
  if(0 == f->w->shown()) {
  	return -1;
  }
  return 0;
}

int guifltk_simgen_clearerrorcodes(void *gen) {
  SimGenGui_Fltk *f = static_cast<SimGenGui_Fltk *>(gen);
  if(NULL == f || 0 == f->w->shown()) {
  	return -1;
  }
  
  f->dtc_report->value(0);
  
  return 0;
}

int guifltk_simgen_geterrorcodes(void *gen, unsigned int *errorcodes, int num_codes, int *mil) {
  SimGenGui_Fltk *f = static_cast<SimGenGui_Fltk *>(gen);
  if(NULL == f || 0 == f->w->shown()) {
  	return -1;
  }
  
  if(0 == f->dtc_report->value() || 0 == f->dtc_list->nitems()) {
  	return 0;
  }
  
  int i;
  for(i=1;i<=f->dtc_list->nitems() && i<num_codes;i++) {
  	unsigned int A = 0;
  	unsigned int B = 0;
  	dtc_humantobytes(f->dtc_list->text(i), &A, &B);
  	errorcodes[2*i-2] = A;
  	errorcodes[2*i-1] = B;
  }
  
  return f->dtc_list->nitems();
}
#include "gen_gui_fltk.c"
